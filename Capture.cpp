/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**  
** Permission is hereby granted, free of charge, to any person or organization 
** obtaining a copy of the software and accompanying documentation (the 
** "Software") to use, reproduce, display, distribute, sub-license, execute, 
** and transmit the Software, and to prepare derivative works of the Software, 
** and to permit third-parties to whom the Software is furnished to do so, in 
** accordance with:
** 
** (1) if the Software is obtained from Blackmagic Design, the End User License 
** Agreement for the Software Development Kit (“EULA”) available at 
** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
** 
** (2) if the Software is obtained from any third party, such licensing terms 
** as notified by that third party,
** 
** and all subject to the following:
** 
** (3) the copyright notices in the Software and this entire statement, 
** including the above license grant, this restriction and the following 
** disclaimer, must be included in all copies of the Software, in whole or in 
** part, and all derivative works of the Software, unless such copies or 
** derivative works are solely in the form of machine-executable object code 
** generated by a source language processor.
** 
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
** DEALINGS IN THE SOFTWARE.
** 
** A copy of the Software is available free of charge at 
** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
** 
** -LICENSE-END-
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <fcntl.h>
#include <csignal>
#include <vector>
#include <numeric>

#include "DeckLinkAPI.h"
#include "Capture.h"
#include "Config.h"

// Audio processing globals
std::vector<double> g_leftChannelPcm;
std::vector<double> g_rightChannelPcm;

const int kAudioSampleRate = 48000;
const int kWindowSizeInSamples = kAudioSampleRate * 400 / 1000; // 19200
const int kSlideSizeInSamples = kAudioSampleRate * 100 / 1000;  // 4800

// Placeholder for the user's loudness calculation function
void calculateLoudness(const std::vector<double>& left, const std::vector<double>& right)
{
    // Example: calculate and print average for verification
    if (!left.empty() && !right.empty())
    {
        double left_avg = std::accumulate(left.begin(), left.end(), 0.0) / left.size();
        double right_avg = std::accumulate(right.begin(), right.end(), 0.0) / right.size();
        printf("  L/R channel average: %f, %f\n", left_avg, right_avg);
    }
}


static pthread_mutex_t	g_sleepMutex;
static pthread_cond_t	g_sleepCond;
static int				g_audioOutputFile = -1;
static bool				g_do_exit = false;

static BMDConfig			g_config;

static IDeckLinkInput*		g_deckLinkInput = NULL;

DeckLinkCaptureDelegate::DeckLinkCaptureDelegate() :
	m_refCount(1)
{
}

ULONG DeckLinkCaptureDelegate::AddRef(void)
{
	return __sync_add_and_fetch(&m_refCount, 1);
}

ULONG DeckLinkCaptureDelegate::Release(void)
{
	int32_t newRefValue = __sync_sub_and_fetch(&m_refCount, 1);
	if (newRefValue == 0)
	{
		delete this;
		return 0;
	}
	return newRefValue;
}

HRESULT DeckLinkCaptureDelegate::VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioFrame)
{
	(void)videoFrame; // Video frames are ignored, but used for timing

	// Handle Audio Frame
	if (audioFrame)
	{
        void* audioFrameBytes;
        audioFrame->GetBytes(&audioFrameBytes);
        unsigned int sampleFrameCount = audioFrame->GetSampleFrameCount();
        unsigned int channelCount = g_config.m_audioChannels;
        unsigned int sampleDepth = g_config.m_audioSampleDepth;

        // We assume stereo audio (2 channels) for L/R separation
        if (channelCount == 2)
        {
            if (sampleDepth == 32)
            {
                int32_t* pcmData = (int32_t*)audioFrameBytes;
                for (unsigned int i = 0; i < sampleFrameCount; ++i)
                {
                    g_leftChannelPcm.push_back((double)pcmData[i * 2] / 2147483648.0);
                    g_rightChannelPcm.push_back((double)pcmData[i * 2 + 1] / 2147483648.0);
                }
            }
            else if (sampleDepth == 16)
            {
                int16_t* pcmData = (int16_t*)audioFrameBytes;
                for (unsigned int i = 0; i < sampleFrameCount; ++i)
                {
                    g_leftChannelPcm.push_back((double)pcmData[i * 2] / 32768.0);
                    g_rightChannelPcm.push_back((double)pcmData[i * 2 + 1] / 32768.0);
                }
            }
        }
        // Note: Non-stereo audio is not handled by this logic.

        // While we have enough data for a 400ms window in both channels
        while (g_leftChannelPcm.size() >= kWindowSizeInSamples && g_rightChannelPcm.size() >= kWindowSizeInSamples)
        {
            // Create vectors for the 400ms window
            std::vector<double> leftWindow(g_leftChannelPcm.begin(), g_leftChannelPcm.begin() + kWindowSizeInSamples);
            std::vector<double> rightWindow(g_rightChannelPcm.begin(), g_rightChannelPcm.begin() + kWindowSizeInSamples);

            // Call the loudness calculation function
            calculateLoudness(leftWindow, rightWindow);

            // Remove the first 100ms (slide the window)
            g_leftChannelPcm.erase(g_leftChannelPcm.begin(), g_leftChannelPcm.begin() + kSlideSizeInSamples);
            g_rightChannelPcm.erase(g_rightChannelPcm.begin(), g_rightChannelPcm.begin() + kSlideSizeInSamples);
        }
	}

	return S_OK;
}

HRESULT DeckLinkCaptureDelegate::VideoInputFormatChanged(BMDVideoInputFormatChangedEvents /*events*/, IDeckLinkDisplayMode* /*mode*/, BMDDetectedVideoInputFormatFlags /*formatFlags*/)
{
	// This callback is for video format changes, which we are ignoring.
	return S_OK;
}

static void sigfunc(int signum)
{
	if (signum == SIGINT || signum == SIGTERM)
			g_do_exit = true;

	pthread_cond_signal(&g_sleepCond);
}

int main(int argc, char *argv[])
{
	HRESULT						result;
	int							exitStatus = 1;

	IDeckLinkIterator*			deckLinkIterator = NULL;
	IDeckLink*					deckLink = NULL;

	IDeckLinkProfileAttributes*	deckLinkAttributes = NULL;
	int64_t						duplexMode;

	IDeckLinkDisplayMode*		displayMode = NULL;

	DeckLinkCaptureDelegate*		delegate = NULL;

	pthread_mutex_init(&g_sleepMutex, NULL);
	pthread_cond_init(&g_sleepCond, NULL);

	signal(SIGINT, sigfunc);
	signal(SIGTERM, sigfunc);
	signal(SIGHUP, sigfunc);

	// Process the command line arguments
	if (!g_config.ParseArguments(argc, argv))
	{
		g_config.DisplayUsage(exitStatus);
		goto bail;
	}

	// Get the DeckLink device
	deckLink = g_config.GetSelectedDeckLink();
	if (deckLink == NULL)
	{
		fprintf(stderr, "Unable to get DeckLink device %u\n", g_config.m_deckLinkIndex);
		goto bail;
	}

	// Get the input (capture) interface of the DeckLink device
	result = deckLink->QueryInterface(IID_IDeckLinkInput, (void**)&g_deckLinkInput);
	if (result != S_OK)
	{
		fprintf(stderr, "The selected device does not have an input interface\n");
		goto bail;
	}

	// Check the DeckLink device is active
	result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);
	if (result != S_OK)
	{
		fprintf(stderr, "Unable to get DeckLink attributes interface\n");
		goto bail;
	}
	result = deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &duplexMode);
	if ((result != S_OK) || (duplexMode == bmdDuplexInactive))
	{
		fprintf(stderr, "The selected DeckLink device is inactive\n");
		goto bail;
	}

	// Enable automatic video format detection to drive the capture clock
    bool formatDetectionSupported;
    result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &formatDetectionSupported);
    if (result == S_OK && formatDetectionSupported)
    {
        g_config.m_inputFlags |= bmdVideoInputEnableFormatDetection;
    }

    // Get a display mode to start with. If format detection is enabled, the SDK will switch to the detected format.
    displayMode = g_config.GetSelectedDeckLinkDisplayMode(deckLink);
    if (displayMode == NULL)
    {
        fprintf(stderr, "Error: Could not find a valid display mode.\n");
        goto bail;
    }

	// Configure the capture callback
	delegate = new DeckLinkCaptureDelegate();
	g_deckLinkInput->SetCallback(delegate);

	// Open audio output file (if specified)
	if (g_config.m_audioOutputFile != NULL)
	{
		g_audioOutputFile = open(g_config.m_audioOutputFile, O_WRONLY|O_CREAT|O_TRUNC, 0664);
		if (g_audioOutputFile < 0)
		{
			fprintf(stderr, "Could not open audio output file \"%s\"\n", g_config.m_audioOutputFile);
			goto bail;
		}
	}

    // Enable video input to act as a capture clock. We use a simple format to minimize resources.
    result = g_deckLinkInput->EnableVideoInput(displayMode->GetDisplayMode(), bmdFormat8BitYUV, g_config.m_inputFlags);
    if (result != S_OK)
    {
        fprintf(stderr, "Failed to enable video input. Is a video signal connected?\n");
        goto bail;
    }

    // Enable audio input
    result = g_deckLinkInput->EnableAudioInput(bmdAudioSampleRate48kHz, g_config.m_audioSampleDepth, g_config.m_audioChannels);
    if (result != S_OK)
    {
        fprintf(stderr, "Failed to enable audio input.\n");
        goto bail;
    }

    // Start capturing
    result = g_deckLinkInput->StartStreams();
    if (result != S_OK)
    {
        fprintf(stderr, "Failed to start streams.\n");
        goto bail;
    }

    printf("Audio capture started. Press Ctrl+C to stop.\n");
	// All Okay.
	exitStatus = 0;

	// Block main thread until signal occurs
	pthread_mutex_lock(&g_sleepMutex);
	pthread_cond_wait(&g_sleepCond, &g_sleepMutex);
	pthread_mutex_unlock(&g_sleepMutex);

    fprintf(stderr, "\nStopping audio capture...\n");
    g_deckLinkInput->StopStreams();
    g_deckLinkInput->DisableAudioInput();
	g_deckLinkInput->DisableVideoInput();


bail:
	if (g_audioOutputFile != 0)
		close(g_audioOutputFile);

	if (displayMode != NULL)
		displayMode->Release();

	if (delegate != NULL)
		delegate->Release();

	if (g_deckLinkInput != NULL)
	{
		g_deckLinkInput->Release();
		g_deckLinkInput = NULL;
	}

	if (deckLinkAttributes != NULL)
		deckLinkAttributes->Release();

	if (deckLink != NULL)
		deckLink->Release();

	if (deckLinkIterator != NULL)
		deckLinkIterator->Release();

	return exitStatus;
}