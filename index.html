<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDI Audio Monitor</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            background-color: #2c3e50;
            color: #ecf0f1;
            box-sizing: border-box;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .monitor-row {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            justify-content: center;
            flex-wrap: wrap;
        }

        .widget-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .levels-widget-container {
            width: 150px;
        }

        h1 {
            margin-bottom: 0;
        }

        h2 {
            margin-bottom: 10px;
        }

        .level-meter-container {
            display: flex;
            flex-direction: row;
            gap: 5px;
            justify-content: center;
            height: 250px;
            align-items: flex-end;
        }

        .level-meter {
            width: 35px;
            height: 220px;
            border: 2px solid #34495e;
            background-color: #1c2833;
            border-radius: 5px;
            position: relative;
        }

        .meter-fill {
            width: 100%;
            height: 0%;
            background-color: #27ae60;
            position: absolute;
            left: 0;
            bottom: 0;
            border-radius: 2px;
        }

        .meter-label {
            position: absolute;
            bottom: -42px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 0.9em;
            font-weight: bold;
        }

        .meter-current-value {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
            color: #bdc3c7;
            font-size: 0.8em;
            font-weight: bold;
        }

        .scale-container {
            height: 220px;
            width: 30px;
            position: relative;
            color: #bdc3c7;
            font-size: 0.8em;
            text-align: right;
        }

        .scale-mark {
            position: absolute;
            width: 100%;
            border-bottom: 1px solid #4a627a;
            padding-right: 5px;
        }

        .vectorscope-container {
            width: 250px;
            height: 250px;
            border: 2px solid #34495e;
            background-color: #000;
            box-sizing: border-box;
        }

        .vectorscope-container img,
        .video-container video {
            width: 100%;
            height: 100%;
        }

        .video-container {
            width: 640px;
            height: 360px;
            border: 2px solid #34495e;
            background-color: #000;
            box-sizing: border-box;
        }

        .videovs-container video {
            width: 100%;
            height: 100%;
        }

        .videovs-container {
            width: 250px;
            height: 250px;
            border: 2px solid #34495e;
            background-color: #000;
            box-sizing: border-box;
            position: relative;
        }

        .videovs-container h2 {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            margin: 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.2em;
            z-index: 10;
            pointer-events: none;
        }

        #videoVectorscopeGrid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Make sure clicks go through to the video */
        }

        .lkfs-widget-container {
            width: 250px;
        }

        .lkfs-display {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #1c2833;
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #34495e;
            height: 240px;
            /* Adjusted height */
            justify-content: center;
        }

        .lra-display {
            display: flex;
            flex-direction: column;
            gap: 5px;
            background-color: #1c2833;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #34495e;
            justify-content: center;
        }

        .lkfs-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5em;
        }

        .lkfs-label {
            font-weight: bold;
            color: #bdc3c7;
        }

        .lkfs-value {
            font-weight: bold;
            min-width: 80px;
            text-align: right;
        }

        #toggleIntegration,
        .placeholder-button {
            background-color: #34495e;
            color: #ecf0f1;
            border: 1px solid #4a627a;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 10px;
        }

        #toggleIntegration:hover {
            background-color: #4a627a;
        }

        .placeholder-button {
            visibility: hidden;
        }

        .lra-bar-container {
            width: 100%;
            height: 10px;
            background-color: #2c3e50;
            border-radius: 3px;
            margin-top: 5px;
            position: relative;
        }

        .lra-bar {
            height: 100%;
            width: 0%;
            background-color: #3498db;
            border-radius: 3px;
        }

        .eq-widget-container {
            width: 500px;
        }

        #eqCanvas {
            border: 2px solid #34495e;
            background-color: #1c2833;
            border-radius: 5px;
        }

        .correlator-container {
            width: 250px;
            height: 25px;
            border: 2px solid #34495e;
            background-color: #1c2833;
            border-radius: 5px;
            position: relative;
            margin-top: 10px;
        }

        .correlator-bar {
            position: absolute;
            width: 0;
            /* Initial width is 0 */
            height: 100%;
            background-color: #27ae60;
            left: 50%;
            /* Initial position is center */
            border-radius: 2px;
        }

        .correlator-scale {
            width: 250px;
            /* Match container width */
            display: flex;
            justify-content: space-between;
            position: relative;
            top: 5px;
            /* Adjust position relative to container */
            font-size: 0.8em;
            color: #bdc3c7;
            padding: 0 5px;
            box-sizing: border-box;
        }

        /* Settings Menu Styles */
        .settings-menu {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .settings-content {
            display: none;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
            background-color: #34495e;
            border-radius: 5px;
            padding: 10px;
        }

        #settings-toggle {
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 1.2em;
            cursor: pointer;
            padding: 5px;
            background-color: #34495e;
            border-radius: 5px;
        }

        .channel-selector {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .channel-selector label {
            font-size: 0.9em;
        }

        .channel-selector select {
            background-color: #2c3e50;
            color: #ecf0f1;
            border: 1px solid #4a627a;
            border-radius: 3px;
            padding: 5px;
        }

        #save-settings {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
        }

        #save-settings:hover {
            background-color: #2ecc71;
        }

        /* Status Display Styles */
        .status-display {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        #status-toggle {
            background-color: #34495e;
            color: #ecf0f1;
            border: 1px solid #4a627a;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
        }

        #status-content {
            display: none;
            background-color: #1c2833;
            border: 2px solid #34495e;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 5px;
            width: 200px;
            font-size: 0.9em;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            /* Align items to the top */
        }

        .status-row span:last-child {
            text-align: right;
        }

        /* Tab Styles */
        .tab-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #34495e;
            width: 90%;
            max-width: 1200px;
        }

        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            background-color: transparent;
            color: #bdc3c7;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1.1em;
        }

        .tab-btn.active {
            color: #ecf0f1;
            border-bottom: 3px solid #3498db;
        }

        .tab-content {
            display: none;
            width: 100%;
            justify-content: center;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>

<body>
    <div class="settings-menu">
        <button id="settings-toggle">⚙️</button>
        <div id="settings-content" class="settings-content">
            <h3>Channel Settings</h3>
            <div class="channel-selector">
                <label for="left-channel">Left Channel:</label>
                <select id="left-channel"></select>
            </div>
            <div class="channel-selector">
                <label for="right-channel">Right Channel:</label>
                <select id="right-channel"></select>
            </div>
            <button id="save-settings">Save & Restart</button>
        </div>
    </div>

    <div class="main-container">
        <h1>Ducky's Monitor</h1>

        <div class="tab-nav">
            <button id="audio-tab-btn" class="tab-btn active">Audio</button>
            <button id="video-tab-btn" class="tab-btn">Video</button>
        </div>

        <div id="audio-tab-content" class="tab-content active">
            <div class="monitor-row">
                <div class="widget-container levels-widget-container">
                    <h2>Levels</h2>
                    <div class="level-meter-container">
                        <div class="scale-container" id="meterScale"></div>
                        <div class="level-meter">
                            <div class="meter-fill" id="leftMeterFill"></div>
                            <span class="meter-current-value" id="leftMeterValue">-inf</span>
                            <span class="meter-label">L</span>
                        </div>
                        <div class="level-meter">
                            <div class="meter-fill" id="rightMeterFill"></div>
                            <span class="meter-current-value" id="rightMeterValue">-inf</span>
                            <span class="meter-label">R</span>
                        </div>
                    </div>
                </div>

                <div class="widget-container lkfs-widget-container">
                    <h2>LKFS</h2>
                    <div class="lkfs-display">
                        <div class="lkfs-row">
                            <span class="lkfs-label">M :</span>
                            <span class="lkfs-value" id="momentaryValue">-inf</span>
                            <button class="placeholder-button">Start</button>
                        </div>
                        <div class="lkfs-row">
                            <span class="lkfs-label">S :</span>
                            <span class="lkfs-value" id="shortTermValue">-inf</span>
                            <button class="placeholder-button">Start</button>
                        </div>
                        <div class="lkfs-row">
                            <span class="lkfs-label">I :</span>
                            <span class="lkfs-value" id="integratedValue">-inf</span>
                            <button id="toggleIntegration">Start</button>
                        </div>
                    </div>
                </div>

                <div class="widget-container">
                    <h2>Correlator</h2>
                    <div class="correlator-container">
                        <div class="correlator-bar" id="correlatorBar"></div>
                    </div>
                    <div class="correlator-scale">
                        <span>-</span>
                        <span>0</span>
                        <span>+</span>
                    </div>
                </div>

                <div class="widget-container lkfs-widget-container">
                    <h2>LRA</h2>
                    <div class="lra-display">
                        <div class="lkfs-row">
                            <div style="flex-basis: 100%;">
                                <div
                                    style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
                                    <span class="lkfs-label">LRA:</span>
                                    <span class="lkfs-value" id="lraValue" style="font-size: 1em;">0.0</span>
                                </div>
                                <div class="lra-bar-container">
                                    <div class="lra-bar" id="lraBar"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="widget-container">
                    <h2>Vectorscope</h2>
                    <div class="vectorscope-container">
                        <img src="/vectorscope.mjpeg" alt="Vectorscope Stream">
                    </div>
                </div>
            </div>
            <div class="monitor-row">
                <div class="widget-container eq-widget-container">
                    <h2>EQ Meter</h2>
                    <canvas id="eqCanvas" width="500" height="250"></canvas>
                </div>
            </div>
        </div>

        <div id="video-tab-content" class="tab-content">
            <div class="widget-container">
                <h2>Video</h2>
                        <div class="video-container">
                            <video id="rawVideo" autoplay playsinline muted></video>
                        </div>
                        <div class="videovs-container">
                            <h2>Video Vectorscope</h2>
                            <video id="vectorscopeVideo" autoplay playsinline muted></video>
                            <canvas id="videoVectorscopeGrid"></canvas>
                        </div>            </div>
        </div>
    </div>

    <div class="status-display">
        <div id="status-content">
            <div class="status-row">
                <span>CPU:</span>
                <span id="cpu-usage">-</span>
            </div>
            <div class="status-row">
                <span>Memory:</span>
                <span id="mem-usage">-</span>
            </div>
        </div>
        <button id="status-toggle">Status</button>
    </div>

    <script>
        // Existing DOM element getters
        const leftMeterFill = document.getElementById('leftMeterFill');
        const rightMeterFill = document.getElementById('rightMeterFill');
        const leftMeterValue = document.getElementById('leftMeterValue');
        const rightMeterValue = document.getElementById('rightMeterValue');
        const meterScale = document.getElementById('meterScale');
        const momentaryValue = document.getElementById('momentaryValue');
        const shortTermValue = document.getElementById('shortTermValue');
        const integratedValue = document.getElementById('integratedValue');
        const lraValue = document.getElementById('lraValue');
        const lraBar = document.getElementById('lraBar');
        const toggleBtn = document.getElementById('toggleIntegration');
        const eqCanvas = document.getElementById('eqCanvas');
        const eqCtx = eqCanvas.getContext('2d');
        const correlatorBar = document.getElementById('correlatorBar');
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsContent = document.getElementById('settings-content');
        const leftChannelSelect = document.getElementById('left-channel');
        const rightChannelSelect = document.getElementById('right-channel');
        const saveSettingsBtn = document.getElementById('save-settings');
        const statusToggle = document.getElementById('status-toggle');
        const statusContent = document.getElementById('status-content');
        const cpuUsageSpan = document.getElementById('cpu-usage');
        const memUsageSpan = document.getElementById('mem-usage');

        // --- Tab Navigation Logic ---
        const audioTabBtn = document.getElementById('audio-tab-btn');
        const videoTabBtn = document.getElementById('video-tab-btn');
        const audioTabContent = document.getElementById('audio-tab-content');
        const videoTabContent = document.getElementById('video-tab-content');

        audioTabBtn.addEventListener('click', () => {
            if (!audioTabBtn.classList.contains('active')) {
                audioTabBtn.classList.add('active');
                videoTabBtn.classList.remove('active');
                audioTabContent.classList.add('active');
                videoTabContent.classList.remove('active');
            }
        });

        videoTabBtn.addEventListener('click', () => {
            if (!videoTabBtn.classList.contains('active')) {
                videoTabBtn.classList.add('active');
                audioTabBtn.classList.remove('active');
                videoTabContent.classList.add('active');
                audioTabContent.classList.remove('active');
            }
        });

        let isIntegrating = false;

        // --- WebRTC Globals ---
        const pc = new RTCPeerConnection();
        let makingAnswer = false;
        let pendingRemoteOffer = null;
        let currentPubId = null;
        const pendingIceCandidates = [];

        // --- WebSocket connection (now with role=sub) ---
        const ws = new WebSocket(`ws://${window.location.host}/?role=sub`);

        // --- WebRTC Functions (from viewer.js) ---
        const handleOffer = async (sdp) => {
            if (makingAnswer) {
                pendingRemoteOffer = sdp;
                return;
            }
            makingAnswer = true;

            try {
                if (pc.signalingState !== "stable") {
                    try {
                        await pc.setLocalDescription({ type: "rollback" });
                    } catch (e) {
                        console.warn("Rollback failed (this is often fine)", e);
                    }
                }

                await pc.setRemoteDescription({ type: "offer", sdp });

                let vtrans = pc.getTransceivers().find(t => t.receiver && t.receiver.track?.kind === "video");
                if (!vtrans) {
                    vtrans = pc.addTransceiver("video", { direction: "recvonly" });
                }

                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                ws.send(JSON.stringify({ type: "answer", sdp: answer.sdp, to: currentPubId }));

                while (pendingIceCandidates.length) {
                    const ice = pendingIceCandidates.shift();
                    try {
                        await pc.addIceCandidate(ice);
                    } catch (e) {
                        console.warn("addIceCandidate(pending) failed", e, ice);
                    }
                }
            } catch (e) {
                console.error("handleOffer failed:", e);
            } finally {
                makingAnswer = false;
                if (pendingRemoteOffer) {
                    const next = pendingRemoteOffer;
                    pendingRemoteOffer = null;
                    handleOffer(next);
                }
            }
        };

        pc.ontrack = (e) => {
            const streamId = e.streams[0]?.id;
            const trackId = e.track.id;

            console.log(`Received track: kind=${e.track.kind}, id=${trackId}, streamId=${streamId}`);

            if (trackId === 'video-raw' || streamId === 'stream-raw') {
                document.getElementById('rawVideo').srcObject = e.streams[0];
            } else if (trackId === 'video-vs' || streamId === 'stream-vectorscope') {
                document.getElementById('vectorscopeVideo').srcObject = e.streams[0];
            } else {
                console.log(`Ignored track ${trackId} (${streamId})`);
            }
        };

        pc.onicecandidate = (e) => {
            if (e.candidate) {
                ws.send(JSON.stringify({
                    type: "candidate",
                    candidate: e.candidate.candidate,
                    mid: e.candidate.sdpMid,
                    sdpMLineIndex: e.candidate.sdpMLineIndex ?? 0,
                    to: currentPubId,
                }));
            }
        };

        pc.oniceconnectionstatechange = () => console.log("PC ICE State:", pc.iceConnectionState);
        pc.onconnectionstatechange = () => console.log("PC Connection State:", pc.connectionState);

        // --- WebSocket Listeners ---
        ws.onopen = () => {
            console.log('Connected to WebSocket server');
            // Request WebRTC offer and existing settings
            ws.send(JSON.stringify({ type: 'need-offer' }));
            ws.send(JSON.stringify({ command: 'get_settings' }));
        };

        ws.onmessage = async (event) => {
            try {
                const text = typeof event.data === "string" ? event.data : await event.data.text();
                const data = JSON.parse(text);

                // --- WebRTC Signaling Handler ---
                if (data.type === 'offer') {
                    console.log("Received WebRTC offer.");
                    currentPubId = data.from || currentPubId;
                    handleOffer(data.sdp);
                    return; // Consumed by WebRTC handler
                } else if (data.type === 'candidate') {
                    try {
                        const ice = {
                            candidate: data.candidate,
                            sdpMLineIndex: typeof data.sdpMLineIndex === "number" ? data.sdpMLineIndex : 0,
                            sdpMid: data.mid ?? null,
                        };
                        if (pc.remoteDescription) {
                            await pc.addIceCandidate(ice);
                        } else {
                            pendingIceCandidates.push(ice);
                        }
                    } catch (e) {
                        console.error("addIceCandidate failed", e, data);
                    }
                    return; // Consumed by WebRTC handler
                }

                // --- Existing Telemetry Handler ---
                if (data.type === 'settings') {
                    leftChannelSelect.value = data.leftAudioChannel;
                    rightChannelSelect.value = data.rightAudioChannel;
                }

                if (data.type === 'system_stats') {
                    cpuUsageSpan.textContent = `${data.cpu.toFixed(1)}%`;
                    const memUsedGb = data.memory.used / (1024 ** 3);
                    const memTotalGb = data.memory.total / (1024 ** 3);
                    memUsageSpan.innerHTML = `${data.memory.percent.toFixed(1)}%<br><small>(${memUsedGb.toFixed(2)}/${memTotalGb.toFixed(2)} GB)</small>`;
                }

                if (data.type === 'integration_state') {
                    isIntegrating = data.is_integrating;
                    if (isIntegrating) {
                        toggleBtn.textContent = 'Stop';
                        toggleBtn.style.backgroundColor = '#e74c3c';
                    } else {
                        toggleBtn.textContent = 'Start';
                        toggleBtn.style.backgroundColor = '#34495e';
                    }
                }

                if (data.type === 'levels') {
                    meterState.left.latestValue = data.left;
                    meterState.right.latestValue = data.right;
                }

                if (data.type === 'correlation') {
                    correlatorState.latestValue = data.value;
                }

                if (data.type === 'eq') {
                    for (let i = 0; i < numEqBands; i++) {
                        if (data.data && data.data[i] !== undefined) {
                            eqState.bands[i].latestValue = data.data[i];
                        }
                    }
                }

                if (data.type === 'lkfs') {
                    momentaryValue.textContent = data.value.toFixed(2);
                }

                if (data.type === 's_lkfs') {
                    shortTermValue.textContent = data.value.toFixed(2);
                }

                if (data.type === 'i_lkfs') {
                    integratedValue.textContent = data.value.toFixed(2);
                }

                if (data.type === 'lra') {
                    const currentLra = data.value;
                    lraValue.textContent = currentLra.toFixed(1);
                    const lraPercentage = Math.min(100, (currentLra / 25) * 100);
                    lraBar.style.width = `${lraPercentage}%`;
                }

            } catch (e) {
                console.error('Error parsing message:', e);
            }
        };

        ws.onclose = () => {
            console.log('Disconnected from WebSocket server');
            momentaryValue.textContent = 'N/A';
            shortTermValue.textContent = 'N/A';
            integratedValue.textContent = 'N/A';
            lraValue.textContent = 'N/A';
        };

        ws.onerror = error => {
            console.error('WebSocket Error:', error);
            momentaryValue.textContent = 'Error';
            shortTermValue.textContent = 'Error';
            integratedValue.textContent = 'Error';
            lraValue.textContent = 'Error';
        };

        // --- Existing Functions and Animation Loop ---
        toggleBtn.onclick = () => {
            const command = isIntegrating ? 'stop_integration' : 'start_integration';
            ws.send(JSON.stringify({ command: command }));
            console.log('Sent command: ' + command);
        };

        function populateChannelSelectors() {
            for (let i = 0; i < 16; i++) {
                const optionL = document.createElement('option');
                optionL.value = i;
                optionL.textContent = `Channel ${i + 1}`;
                leftChannelSelect.appendChild(optionL);
                const optionR = document.createElement('option');
                optionR.value = i;
                optionR.textContent = `Channel ${i + 1}`;
                rightChannelSelect.appendChild(optionR);
            }
        }

        settingsToggle.onclick = () => {
            const isDisplayed = settingsContent.style.display === 'flex';
            settingsContent.style.display = isDisplayed ? 'none' : 'flex';
        };

        saveSettingsBtn.onclick = () => {
            const leftChannel = leftChannelSelect.value;
            const rightChannel = rightChannelSelect.value;
            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ leftChannel, rightChannel }),
            })
                .then(response => response.json())
                .then(data => {
                    console.log('Settings saved:', data);
                    alert('Settings saved and Capture process restarted.');
                    settingsContent.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error saving settings:', error);
                    alert('Error saving settings.');
                });
        };

        populateChannelSelectors();

        statusToggle.onclick = () => {
            const isDisplayed = statusContent.style.display === 'block';
            statusContent.style.display = isDisplayed ? 'none' : 'block';
        };

        const minDb = -60.0, maxDb = 0.0, minDbEq = -40.0, maxDbEq = 5.0;
        let meterState = { left: { latestValue: minDb, displayValue: minDb }, right: { latestValue: minDb, displayValue: minDb } };
        const numEqBands = 64;
        let eqState = { bands: Array.from({ length: numEqBands }, () => ({ latestValue: minDbEq, displayValue: minDbEq })) };
        let correlatorState = { latestValue: 0, displayValue: 0 };

        function dbToPercentage(db) {
            let percentage = ((db - minDb) / (maxDb - minDb)) * 100;
            return Math.max(0, Math.min(100, percentage));
        }

        function createScale() {
            const scalePoints = [0, -6, -12, -18, -24, -30, -40, -50, -60];
            scalePoints.forEach(db => {
                const mark = document.createElement('div');
                mark.className = 'scale-mark';
                const percentage = dbToPercentage(db);
                mark.style.bottom = `${percentage}%`;
                mark.innerHTML = `<span>${db}</span>`;
                meterScale.appendChild(mark);
            });
        }

        function updateMeterDOM(fillElement, dbValue) {
            const percentage = dbToPercentage(dbValue);
            fillElement.style.height = `${percentage}%`;
            if (dbValue > -6) fillElement.style.backgroundColor = '#e74c3c';
            else if (dbValue > -12) fillElement.style.backgroundColor = '#f1c40f';
            else fillElement.style.backgroundColor = '#27ae60';
        }

        function drawEq() {
            const canvas = eqCtx.canvas, axisYWidth = 30, axisXHeight = 20;
            const meterWidth = canvas.width - axisYWidth, meterHeight = canvas.height - axisXHeight;
            eqCtx.clearRect(0, 0, canvas.width, canvas.height);
            eqCtx.save();
            eqCtx.translate(axisYWidth, 0);
            const barWidth = meterWidth / numEqBands;
            for (let i = 0; i < numEqBands; i++) {
                const db = eqState.bands[i].displayValue;
                const percent = (db - minDbEq) / (maxDbEq - minDbEq);
                const barHeight = Math.max(0, meterHeight * percent);
                if (db > 0) eqCtx.fillStyle = '#e74c3c';
                else if (db > -9) eqCtx.fillStyle = '#f1c40f';
                else eqCtx.fillStyle = '#27ae60';
                const x = i * barWidth;
                const y = meterHeight - barHeight;
                eqCtx.fillRect(x, y, barWidth - 1, barHeight);
            }
            eqCtx.fillStyle = '#bdc3c7';
            eqCtx.font = '10px sans-serif';
            eqCtx.textAlign = 'center';
            const freqLabels = [30, 60, 125, 250, 500, 1000, 2000, 4000, 8000, 16000];
            const min_log_freq = Math.log(20), max_log_freq = Math.log(20000), log_range = max_log_freq - min_log_freq;
            freqLabels.forEach(freq => {
                const log_freq = Math.log(freq);
                const x = meterWidth * (log_freq - min_log_freq) / log_range;
                eqCtx.fillText(freq < 1000 ? freq : `${freq / 1000}k`, x, canvas.height - 5);
            });
            eqCtx.restore();
            eqCtx.save();
            eqCtx.fillStyle = '#bdc3c7';
            eqCtx.font = '10px sans-serif';
            eqCtx.textAlign = 'right';
            const dbLabels = [0, -9, -18, -27, -36];
            dbLabels.forEach(db => {
                const percent = (db - minDbEq) / (maxDbEq - minDbEq);
                const y = meterHeight - (meterHeight * percent);
                eqCtx.fillText(db, axisYWidth - 8, y + 3);
                eqCtx.strokeStyle = '#4a627a';
                eqCtx.beginPath();
                eqCtx.moveTo(axisYWidth - 4, y);
                eqCtx.lineTo(canvas.width, y);
                eqCtx.stroke();
            });
            eqCtx.restore();
        }

        let lastFrameTime = performance.now();
        const fallRate = 15;

        function animationLoop(currentTime) {
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            let leftState = meterState.left;
            if (leftState.latestValue > leftState.displayValue) leftState.displayValue = leftState.latestValue;
            else leftState.displayValue = Math.max(leftState.displayValue - fallRate * (deltaTime / 1000), minDb);
            let rightState = meterState.right;
            if (rightState.latestValue > rightState.displayValue) rightState.displayValue = rightState.latestValue;
            else rightState.displayValue = Math.max(rightState.displayValue - fallRate * (deltaTime / 1000), minDb);
            updateMeterDOM(leftMeterFill, leftState.displayValue);
            updateMeterDOM(rightMeterFill, rightState.displayValue);
            leftMeterValue.textContent = leftState.displayValue.toFixed(1);
            rightMeterValue.textContent = rightState.displayValue.toFixed(1);
            for (let i = 0; i < numEqBands; i++) {
                let band = eqState.bands[i];
                if (band.latestValue > band.displayValue) band.displayValue = band.latestValue;
                else band.displayValue = Math.max(band.displayValue - fallRate * (deltaTime / 1000), minDbEq);
            }
            drawEq();
            const corrFallRate = 2.0, decay = corrFallRate * (deltaTime / 1000);
            if (Math.abs(correlatorState.latestValue) > Math.abs(correlatorState.displayValue)) correlatorState.displayValue = correlatorState.latestValue;
            if (correlatorState.displayValue > 0) correlatorState.displayValue = Math.max(0, correlatorState.displayValue - decay);
            else if (correlatorState.displayValue < 0) correlatorState.displayValue = Math.min(0, correlatorState.displayValue + decay);
            if (Math.abs(correlatorState.latestValue) > Math.abs(correlatorState.displayValue)) correlatorState.displayValue = correlatorState.latestValue;
            if (correlatorBar) {
                const displayValue = correlatorState.displayValue;
                if (displayValue >= 0) {
                    correlatorBar.style.left = '50%';
                    correlatorBar.style.width = (displayValue * 50) + '%';
                } else {
                    const width = -displayValue * 50;
                    correlatorBar.style.left = (50 - width) + '%';
                    correlatorBar.style.width = width + '%';
                }
            }
            requestAnimationFrame(animationLoop);
        }

        createScale();

        const videoVectorscopeCanvas = document.getElementById('videoVectorscopeGrid');
        if (videoVectorscopeCanvas) {
            const videoVsCtx = videoVectorscopeCanvas.getContext('2d');

            function drawVideoVectorscopeGrid() {
                const canvas = videoVectorscopeCanvas;
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                const ctx = videoVsCtx;
                const width = canvas.width;
                const height = canvas.height;

                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.clearRect(0, 0, width, height);

                // XY axes
                ctx.beginPath();
                ctx.moveTo(width / 2, 0);
                ctx.lineTo(width / 2, height);
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // Diagonal axes
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(width, height);
                ctx.moveTo(0, height);
                ctx.lineTo(width, 0);
                ctx.stroke();
            }

            // Redraw when the video is loaded and playing, as canvas dimensions might not be ready initially
            const videoVsVideo = document.getElementById('vectorscopeVideo');
            videoVsVideo.addEventListener('playing', drawVideoVectorscopeGrid);

            // Also draw on resize
            window.addEventListener('resize', drawVideoVectorscopeGrid);
            
            // Initial draw
            drawVideoVectorscopeGrid();
        }

        requestAnimationFrame(animationLoop);
    </script>
</body>

</html>